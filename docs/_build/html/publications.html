
<!DOCTYPE html>


<html lang="fr" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Publications &#8212; HQI</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="_static/documentation_options.js?v=72dce1d2"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="_static/translations.js?v=bf059b8c"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'publications';</script>
    <link rel="canonical" href="https://hqi-france.github.io/publications.html" />
    <link rel="icon" href="_static/logo.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="prev" title="Qimaera" href="qimaera.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="fr"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Passer au contenu principal</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Haut de page
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/logo.jpg" class="logo__image only-light" alt="HQI - Home"/>
    <script>document.write(`<img src="_static/logo.jpg" class="logo__image only-dark" alt="HQI - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Recherche" aria-label="Recherche" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Recherche</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Le programme HQI
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Accès</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="edari.html">Ressources de calcul</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Environnements</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="myqlm.html">Qaptiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="pulser.html">Pulser</a></li>
<li class="toctree-l1"><a class="reference internal" href="perceval.html">Perceval</a></li>
<li class="toctree-l1"><a class="reference internal" href="qubo.html">Etude de cas QUBO</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Outils</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="qbricks.html">Qbricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="qimaera.html">Qimaera</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Publications</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/HQI-France/Tutoriel" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Dépôt source"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Téléchargez cette page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/publications.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Télécharger le fichier source"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Imprimer au format PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Mode plein écran"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="clair/sombre" aria-label="clair/sombre" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Recherche" aria-label="Recherche" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Publications</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contenu </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#calcul-hybride-classique-quantique">Calcul hybride classique/quantique</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithme-circuit">Algorithme/circuit</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#formal-methods-for-quantum-programs-a-survey">Formal Methods for Quantum Programs: A Survey</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#optimal-hadamard-gate-count-for-clifford-t-synthesis-of-pauli-rotations-sequences">Optimal Hadamard gate count for Clifford<span class="math notranslate nohighlight">\(+T\)</span> synthesis of Pauli rotations sequences</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#on-the-hardness-of-analyzing-quantum-programs-quantitatively">On the Hardness of Analyzing Quantum Programs Quantitatively</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#completeness-of-sum-over-paths-for-toffoli-hadamard-and-the-dyadic-fragments-of-quantum-computation">Completeness of Sum-Over-Paths for Toffoli-Hadamard and the Dyadic Fragments of Quantum Computation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rewriting-and-completeness-of-sum-over-paths-in-dyadic-fragments-of-quantum-computing">Rewriting and Completeness of Sum-Over-Paths in Dyadic Fragments of Quantum Computing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-complete-equational-theory-for-quantum-circuits">A Complete Equational Theory for Quantum Circuits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-circuit-completeness-extensions-and-simplifications">Quantum Circuit Completeness: Extensions and Simplifications</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-curry-howard-correspondence-for-linear-reversible-computation">A Curry-Howard Correspondence for Linear, Reversible Computation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proceedings-of-the-twentieth-international-conference-on-quantum-physics-and-logic">Proceedings of the Twentieth International Conference on Quantum Physics and Logic</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimal-equational-theories-for-quantum-circuits">Minimal Equational Theories for Quantum Circuits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-pragma-based-c-framework-for-hybrid-quantum-classical-computation">A Pragma-Based C Framework for Hybrid Quantum Classical Computation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-tree-approach-pauli-decomposition-algorithm-with-application-to-quantum-computing">A tree-approach Pauli decomposition algorithm with application to quantum computing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#experimenting-with-hybrid-quantum-optimization-in-hpc-software-stack-for-cpu-register-allocation">Experimenting with hybrid quantum optimization in HPC software stack for CPU register allocation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-computing-with-and-for-many-body-physics">Quantum computing with and for many-body physics</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#langage-de-programmation">Langage de programmation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-programming-language-characterizing-quantum-polynomial-time">A programming language characterizing quantum polynomial time</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-expectation-transformers-for-cost-analysis">Quantum Expectation Transformers for Cost Analysis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qimaera-type-safe-variational-quantum-programming-in-idris">Qimaera: Type-safe (Variational) Quantum Programming in Idris</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#addition-and-differentiation-of-zx-diagrams">Addition and Differentiation of ZX-diagrams</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lov-calculus-a-graphical-language-for-linear-optical-quantum-circuits">LOv-Calculus: A Graphical Language for Linear Optical Quantum Circuits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#perceval-a-software-platform-for-discrete-variable-photonic-quantum-computing">Perceval: A Software Platform for Discrete Variable Photonic Quantum Computing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#physique">Physique</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#efficient-and-robust-estimation-of-many-qubit-hamiltonians">Efficient and robust estimation of many-qubit Hamiltonians</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#efficient-learning-of-ground-thermal-states-within-phases-of-matter">Efficient learning of ground &amp; thermal states within phases of matter</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#provably-efficient-learning-of-phases-of-matter-via-dissipative-evolutions">Provably Efficient Learning of Phases of Matter via Dissipative Evolutions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#many-body-entropies-and-entanglement-from-polynomially-many-local-measurements">Many-body entropies and entanglement from polynomially-many local measurements</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#chimie">Chimie</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#greedy-gradient-free-adaptive-variational-quantum-algorithms-on-a-noisy-intermediate-scale-quantum-computer">Greedy Gradient-free Adaptive Variational Quantum Algorithms on a Noisy Intermediate Scale Quantum Computer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#overlap-adapt-vqe-practical-quantum-chemistry-on-quantum-computers-via-overlap-guided-compact-ansatze">Overlap-ADAPT-VQE: Practical Quantum Chemistry on Quantum Computers via Overlap-Guided Compact Ansätze</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sparse-quantum-state-preparation-for-strongly-correlated-systems">Sparse Quantum State Preparation for Strongly Correlated Systems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dilute-measurement-induced-cooling-into-many-body-ground-states">Dilute measurement-induced cooling into many-body ground states</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#machine-learning-optimisation">Machine learning/optimisation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#trainability-and-expressivity-of-hamming-weight-preserving-quantum-circuits-for-machine-learning">Trainability and Expressivity of Hamming-Weight Preserving Quantum Circuits for Machine Learning</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-higher-order-binary-optimization-problems-on-nisq-devices-experiments-and-limitations">Solving Higher Order Binary Optimization Problems on NISQ Devices: Experiments and Limitations</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cryptographie-cryptanalyse">Cryptographie/cryptanalyse</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#variational-loop-vertex-expansion">Variational Loop Vertex Expansion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#even-cycle-detection-in-the-randomized-and-quantum-congest-model">Even-Cycle Detection in the Randomized and Quantum CONGEST Model</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-functional-analysis-approach-to-symbolic-regression">A Functional Analysis Approach to Symbolic Regression</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-complexity-of-testing-signed-graph-clusterability">(Quantum) complexity of testing signed graph clusterability</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-speedups-for-linear-programming-via-interior-point-methods">Quantum speedups for linear programming via interior point methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-walks-the-discrete-wave-equation-and-chebyshev-polynomials">Quantum walks, the discrete wave equation and Chebyshev polynomials</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-security-of-subset-cover-problems">Quantum security of subset cover problems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-special-case-of-cyclotomic-fields-in-quantum-algorithms-for-unit-groups">The special case of cyclotomic fields in quantum algorithms for unit groups</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#caracterisation-correction-d-erreur">Caractérisation/correction d’erreur</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#efficient-learning-of-the-structure-and-parameters-of-local-pauli-noise-channels">Efficient learning of the structure and parameters of local Pauli noise channels</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#information-theoretic-generalization-bounds-for-learning-from-quantum-data">Information-theoretic generalization bounds for learning from quantum data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lower-bounds-on-learning-pauli-channels">Lower Bounds on Learning Pauli Channels</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#robust-sparse-iqp-sampling-in-constant-depth">Robust sparse IQP sampling in constant depth</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unifying-quantum-verification-and-error-detection-theory-and-tools-for-optimisations">Unifying Quantum Verification and Error-Detection: Theory and Tools for Optimisations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#an-automated-deductive-verification-framework-for-circuit-building-quantum-programs">An Automated Deductive Verification Framework for Circuit-building Quantum Programs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fasquic-flexible-architecture-for-scalable-spin-qubit-control">FASQuiC: Flexible architecture for scalable spin qubit control</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="publications">
<h1>Publications<a class="headerlink" href="#publications" title="Lien vers cette rubrique">#</a></h1>
<p>Ce document présente une liste de publications ayant bénéficié du programme HQI.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>La plupart des publications sont référencées sur le portail <a href="https://haltools.archives-ouvertes.fr/Public/afficheRequetePubli.php?projet_anr=ANR-22-PNCQ-0002&CB_auteur=oui&CB_titre=oui&CB_DOI=oui&CB_resume=oui&langue=Francais&tri_exp=annee_publi&tri_exp2=typdoc&tri_exp3=date_publi&ordre_aff=TA&CB_rubriqueDiv=oui&Fen=Aff&css=../css/VisuCondense.css">HAL HQI-R&amp;D Support</a> et <a href="https://haltools.archives-ouvertes.fr/Public/afficheRequetePubli.php?projet_anr=ANR-22-PNCQ-0001&CB_auteur=oui&CB_titre=oui&CB_DOI=oui&CB_resume=oui&langue=Francais&tri_exp=annee_publi&tri_exp2=typdoc&tri_exp3=date_publi&ordre_aff=TA&CB_rubriqueDiv=oui&Fen=Aff&css=../css/VisuCondense.css">HAL HQI-Acquisition</a>. Cependant, certaines publications étant mal référencées, vous trouverez ici les preprints ArXiv.</p>
</div>
<section id="calcul-hybride-classique-quantique">
<h2>Calcul hybride classique/quantique<a class="headerlink" href="#calcul-hybride-classique-quantique" title="Lien vers cette rubrique">#</a></h2>
<p><a class="reference internal" href="#a-pragma-based-c-framework-for-hybrid-quantum-classical-computation">A Pragma-Based C Framework for Hybrid Quantum Classical Computation</a></p>
<p><a class="reference internal" href="#a-tree-approach-pauli-decomposition-algorithm-with-application-to-quantum-computing">A tree-approach Pauli decomposition algorithm with application to quantum computing</a></p>
<p><a class="reference internal" href="#experimenting-with-hybrid-quantum-optimization-in-hpc-software-stack-for-cpu-register-allocation">Experimenting with hybrid quantum optimization in HPC software stack for CPU register allocation</a></p>
<p><a class="reference internal" href="#greedy-gradient-free-adaptive-variational-quantum-algorithms-on-a-noisy-intermediate-scale-quantum-computer">Greedy Gradient-free Adaptive Variational Quantum Algorithms on a Noisy Intermediate Scale Quantum Computer</a></p>
<p><a class="reference internal" href="#qimaera-type-safe-variational-quantum-programming-in-idris">Qimaera: Type-safe (Variational) Quantum Programming in Idris</a></p>
<p><a class="reference internal" href="#formal-methods-for-quantum-programs-a-survey">Formal Methods for Quantum Programs: A Survey</a></p>
<p><a class="reference internal" href="#overlap-adapt-vqe-practical-quantum-chemistry-on-quantum-computers-via-overlap-guided-compact-ansatze">Overlap-ADAPT-VQE: Practical Quantum Chemistry on Quantum Computers via Overlap-Guided Compact Ansätze</a></p>
<p><a class="reference internal" href="#quantum-expectation-transformers-for-cost-analysis">Quantum Expectation Transformers for Cost Analysis</a></p>
<p><a class="reference internal" href="#many-body-entropies-and-entanglement-from-polynomially-many-local-measurements">Many-body entropies and entanglement from polynomially-many local measurements</a></p>
<p><a class="reference internal" href="#information-theoretic-generalization-bounds-for-learning-from-quantum-data">Information-theoretic generalization bounds for learning from quantum data</a></p>
<p><a class="reference internal" href="#provably-efficient-learning-of-phases-of-matter-via-dissipative-evolutions">Provably Efficient Learning of Phases of Matter via Dissipative Evolutions</a></p>
<p><a class="reference internal" href="#trainability-and-expressivity-of-hamming-weight-preserving-quantum-circuits-for-machine-learning">Trainability and Expressivity of Hamming-Weight Preserving Quantum Circuits for Machine Learning</a></p>
<p><a class="reference internal" href="#robust-sparse-iqp-sampling-in-constant-depth">Robust sparse IQP sampling in constant depth</a></p>
<p><a class="reference internal" href="#sparse-quantum-state-preparation-for-strongly-correlated-systems">Sparse Quantum State Preparation for Strongly Correlated Systems</a></p>
</section>
<section id="algorithme-circuit">
<h2>Algorithme/circuit<a class="headerlink" href="#algorithme-circuit" title="Lien vers cette rubrique">#</a></h2>
<section id="formal-methods-for-quantum-programs-a-survey">
<span id="id1"></span><h3>Formal Methods for Quantum Programs: A Survey<a class="headerlink" href="#formal-methods-for-quantum-programs-a-survey" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2109.06493v2">ArXiv</a></p>
<p><strong>Date de publication :</strong> 14/09/2021</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Christophe Chareton</p></li>
<li><p>Sébastien Bardin</p></li>
<li><p>Dongho Lee</p></li>
<li><p>Benoît Valiron</p></li>
<li><p>Renaud Vilmart</p></li>
<li><p>Zhaowei Xu</p></li>
</ul>
<p><strong>Résumé :</strong>
While recent progress in quantum hardware open the door for significant
speedup in certain key areas (cryptography, biology, chemistry, optimization,
machine learning, etc), quantum algorithms are still hard to implement right,
and the validation of such quantum programs is achallenge. Moreover, importing
the testing and debugging practices at use in classical programming is
extremely difficult in the quantum case, due to the destructive aspect of
quantum measurement. As an alternative strategy, formal methods are prone to
play a decisive role in the emerging field of quantum software. Recent works
initiate solutions for problems occurring at every stage of the development
process: high-level program design, implementation, compilation, etc. We review
the induced challenges for an efficient use of formal methods in quantum
computing and the current most promising research directions.</p>
</section>
<section id="optimal-hadamard-gate-count-for-clifford-t-synthesis-of-pauli-rotations-sequences">
<h3>Optimal Hadamard gate count for Clifford<span class="math notranslate nohighlight">\(+T\)</span> synthesis of Pauli rotations sequences<a class="headerlink" href="#optimal-hadamard-gate-count-for-clifford-t-synthesis-of-pauli-rotations-sequences" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2302.07040v3">ArXiv</a></p>
<p><strong>Date de publication :</strong> 14/02/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Vivien Vandaele</p></li>
<li><p>Simon Martiel</p></li>
<li><p>Simon Perdrix</p></li>
<li><p>Christophe Vuillot</p></li>
</ul>
<p><strong>Résumé :</strong>
The Clifford<span class="math notranslate nohighlight">\(+T\)</span> gate set is commonly used to perform universal quantum
computation. In such setup the <span class="math notranslate nohighlight">\(T\)</span> gate is typically much more expensive to
implement in a fault-tolerant way than Clifford gates. To improve the
feasibility of fault-tolerant quantum computing it is then crucial to minimize
the number of <span class="math notranslate nohighlight">\(T\)</span> gates. Many algorithms, yielding effective results, have been
designed to address this problem. It has been demonstrated that performing a
pre-processing step consisting of reducing the number of Hadamard gates in the
circuit can help to exploit the full potential of these algorithms and thereby
lead to a substantial <span class="math notranslate nohighlight">\(T\)</span>-count reduction. Moreover, minimizing the number of
Hadamard gates also restrains the number of additional qubits and operations
resulting from the gadgetization of Hadamard gates, a procedure used by some
compilers to further reduce the number of <span class="math notranslate nohighlight">\(T\)</span> gates. In this work we tackle the
Hadamard gate reduction problem, and propose an algorithm for synthesizing a
sequence of <span class="math notranslate nohighlight">\(\pi/4\)</span> Pauli rotations with a minimal number of Hadamard gates.
Based on this result, we present an algorithm which optimally minimizes the
number of Hadamard gates lying between the first and the last <span class="math notranslate nohighlight">\(T\)</span> gate of the
circuit.</p>
</section>
<section id="on-the-hardness-of-analyzing-quantum-programs-quantitatively">
<h3>On the Hardness of Analyzing Quantum Programs Quantitatively<a class="headerlink" href="#on-the-hardness-of-analyzing-quantum-programs-quantitatively" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2312.13657v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 21/12/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Martin Avanzini</p></li>
<li><p>Georg Moser</p></li>
<li><p>Romain Péchoux</p></li>
<li><p>Simon Perdrix</p></li>
</ul>
<p><strong>Résumé :</strong>
In this paper, we study quantitative properties of quantum programs.
Properties of interest include (positive) almost-sure termination, expected
runtime or expected cost, that is, for example, the expected number of
applications of a given quantum gate, etc. After studying the completeness of
these problems in the arithmetical hierarchy over the Clifford+T fragment of
quantum mechanics, we express these problems using a variation of a quantum
pre-expectation transformer, a weakest precondition based technique that allows
to symbolically compute these quantitative properties. Under a smooth
restriction-a restriction to polynomials of bounded degree over a real closed
field-we show that the quantitative problem, which consists in finding an
upper-bound to the pre-expectation, can be decided in time double-exponential
in the size of a program, thus providing, despite its great complexity, one of
the first decidable results on the analysis and verification of quantum
programs. Finally, we sketch how the latter can be transformed into an
efficient synthesis method.</p>
</section>
<section id="completeness-of-sum-over-paths-for-toffoli-hadamard-and-the-dyadic-fragments-of-quantum-computation">
<h3>Completeness of Sum-Over-Paths for Toffoli-Hadamard and the Dyadic Fragments of Quantum Computation<a class="headerlink" href="#completeness-of-sum-over-paths-for-toffoli-hadamard-and-the-dyadic-fragments-of-quantum-computation" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2205.02600v2">ArXiv</a></p>
<p><strong>Date de publication :</strong> 05/05/2022</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Renaud Vilmart</p></li>
</ul>
<p><strong>Résumé :</strong>
The « Sum-Over-Paths » formalism is a way to symbolically manipulate linear
maps that describe quantum systems, and is a tool that is used in formal
verification of such systems. We give here a new set of rewrite rules for the
formalism, and show that it is complete for « Toffoli-Hadamard », the simplest
approximately universal fragment of quantum mechanics. We show that the
rewriting is terminating, but not confluent (which is expected from the
universality of the fragment). We do so using the connection between
Sum-over-Paths and graphical language ZH-Calculus, and also show how the
axiomatisation translates into the latter. Finally, we show how to enrich the
rewrite system to reach completeness for the dyadic fragments of quantum
computation – obtained by adding phase gates with dyadic multiples of <span class="math notranslate nohighlight">\(\pi\)</span> to
the Toffoli-Hadamard gate-set – used in particular in the Quantum Fourier
Transform.</p>
</section>
<section id="rewriting-and-completeness-of-sum-over-paths-in-dyadic-fragments-of-quantum-computing">
<h3>Rewriting and Completeness of Sum-Over-Paths in Dyadic Fragments of Quantum Computing<a class="headerlink" href="#rewriting-and-completeness-of-sum-over-paths-in-dyadic-fragments-of-quantum-computing" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2307.14223v4">ArXiv</a></p>
<p><strong>Date de publication :</strong> 26/07/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Renaud Vilmart</p></li>
</ul>
<p><strong>Résumé :</strong>
The « Sum-Over-Paths » formalism is a way to symbolically manipulate linear
maps that describe quantum systems, and is a tool that is used in formal
verification of such systems. We give here a new set of rewrite rules for the
formalism, and show that it is complete for « Toffoli-Hadamard », the simplest
approximately universal fragment of quantum mechanics. We show that the
rewriting is terminating, but not confluent (which is expected from the
universality of the fragment). We do so using the connection between
Sum-over-Paths and graphical language ZH-calculus, and also show how the
axiomatisation translates into the latter. We provide generalisations of the
presented rewrite rules, that can prove useful when trying to reduce terms in
practice, and we show how to graphically make sense of these new rules. We show
how to enrich the rewrite system to reach completeness for the dyadic fragments
of quantum computation, used in particular in the Quantum Fourier Transform,
and obtained by adding phase gates with dyadic multiples of <span class="math notranslate nohighlight">\(\pi\)</span> to the
Toffoli-Hadamard gate-set. Finally, we show how to perform sums and
concatenation of arbitrary terms, something which is not native in a system
designed for analysing gate-based quantum computation, but necessary when
considering Hamiltonian-based quantum computation.</p>
</section>
<section id="a-complete-equational-theory-for-quantum-circuits">
<h3>A Complete Equational Theory for Quantum Circuits<a class="headerlink" href="#a-complete-equational-theory-for-quantum-circuits" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2206.10577v2">ArXiv</a></p>
<p><strong>Date de publication :</strong> 21/06/2022</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Alexandre Clément</p></li>
<li><p>Nicolas Heurtel</p></li>
<li><p>Shane Mansfield</p></li>
<li><p>Simon Perdrix</p></li>
<li><p>Benoît Valiron</p></li>
</ul>
<p><strong>Résumé :</strong>
We introduce the first complete equational theory for quantum circuits. More
precisely, we introduce a set of circuit equations that we prove to be sound
and complete: two circuits represent the same unitary map if and only if they
can be transformed one into the other using the equations. The proof is based
on the properties of multi-controlled gates – that are defined using
elementary gates – together with an encoding of quantum circuits into linear
optical circuits, which have been proved to have a complete axiomatisation.</p>
</section>
<section id="quantum-circuit-completeness-extensions-and-simplifications">
<h3>Quantum Circuit Completeness: Extensions and Simplifications<a class="headerlink" href="#quantum-circuit-completeness-extensions-and-simplifications" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2303.03117v3">ArXiv</a></p>
<p><strong>Date de publication :</strong> 06/03/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Alexandre Clément</p></li>
<li><p>Noé Delorme</p></li>
<li><p>Simon Perdrix</p></li>
<li><p>Renaud Vilmart</p></li>
</ul>
<p><strong>Résumé :</strong>
Although quantum circuits have been ubiquitous for decades in quantum
computing, the first complete equational theory for quantum circuits has only
recently been introduced. Completeness guarantees that any true equation on
quantum circuits can be derived from the equational theory. We improve this
completeness result in two ways: (i) We simplify the equational theory by
proving that several rules can be derived from the remaining ones. In
particular, two out of the three most intricate rules are removed, the third
one being slightly simplified. (ii) The complete equational theory can be
extended to quantum circuits with ancillae or qubit discarding, to represent
respectively quantum computations using an additional workspace, and hybrid
quantum computations. We show that the remaining intricate rule can be greatly
simplified in these more expressive settings, leading to equational theories
where all equations act on a bounded number of qubits. The development of
simple and complete equational theories for expressive quantum circuit models
opens new avenues for reasoning about quantum circuits. It provides strong
formal foundations for various compiling tasks such as circuit optimisation,
hardware constraint satisfaction and verification.</p>
</section>
<section id="a-curry-howard-correspondence-for-linear-reversible-computation">
<h3>A Curry-Howard Correspondence for Linear, Reversible Computation<a class="headerlink" href="#a-curry-howard-correspondence-for-linear-reversible-computation" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2302.11887v3">ArXiv</a></p>
<p><strong>Date de publication :</strong> 23/02/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Kostia Chardonnet</p></li>
<li><p>Alexis Saurin</p></li>
<li><p>Benoît Valiron</p></li>
</ul>
<p><strong>Résumé :</strong>
In this paper, we present a linear and reversible programming language with
inductives types and recursion. The semantics of the languages is based on
pattern-matching; we show how ensuring syntactical exhaustivity and
non-overlapping of clauses is enough to ensure reversibility. The language
allows to represent any Primitive Recursive Function. We then give a
Curry-Howard correspondence with the logic <span class="math notranslate nohighlight">\(\mu\)</span>MALL: linear logic extended
with least fixed points allowing inductive statements. The critical part of our
work is to show how primitive recursion yields circular proofs that satisfy
<span class="math notranslate nohighlight">\(\mu\)</span>MALL validity criterion and how the language simulates the cut-elimination
procedure of <span class="math notranslate nohighlight">\(\mu\)</span>MALL.</p>
</section>
<section id="proceedings-of-the-twentieth-international-conference-on-quantum-physics-and-logic">
<h3>Proceedings of the Twentieth International Conference on Quantum Physics and Logic<a class="headerlink" href="#proceedings-of-the-twentieth-international-conference-on-quantum-physics-and-logic" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2308.15489v2">ArXiv</a></p>
<p><strong>Date de publication :</strong> 23/08/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Shane Mansfield</p></li>
<li><p>Benoît Valiron</p></li>
<li><p>Vladimir Zamdzhiev</p></li>
</ul>
<p><strong>Résumé :</strong>
This volume contains the proceedings of the 20th International Conference on
Quantum Physics and Logic (QPL 2023). The aim of the QPL conference series is
to bring together academic and industry researchers working on mathematical
foundations of quantum computation, quantum physics, and related areas. The
main focus is on the use of algebraic and categorical structures, formal
languages, type systems, semantic methods, as well as other mathematical and
computer scientific techniques applicable to the study of physical systems,
physical processes, and their composition.</p>
</section>
<section id="minimal-equational-theories-for-quantum-circuits">
<h3>Minimal Equational Theories for Quantum Circuits<a class="headerlink" href="#minimal-equational-theories-for-quantum-circuits" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2311.07476v2">ArXiv</a></p>
<p><strong>Date de publication :</strong> 13/11/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Alexandre Clément</p></li>
<li><p>Noé Delorme</p></li>
<li><p>Simon Perdrix</p></li>
</ul>
<p><strong>Résumé :</strong>
We introduce the first minimal and complete equational theory for quantum
circuits. Hence, we show that any true equation on quantum circuits can be
derived from simple rules, all of them being standard except a novel but
intuitive one which states that a multi-control <span class="math notranslate nohighlight">\(2\pi\)</span> rotation is nothing but
the identity. Our work improves on the recent complete equational theories for
quantum circuits, by getting rid of several rules including a fairly
impractical one. One of our main contributions is to prove the minimality of
the equational theory, i.e. none of the rules can be derived from the other
ones. More generally, we demonstrate that any complete equational theory on
quantum circuits (when all gates are unitary) requires rules acting on an
unbounded number of qubits. Finally, we also simplify the complete equational
theories for quantum circuits with ancillary qubits and/or qubit discarding.</p>
</section>
<section id="a-pragma-based-c-framework-for-hybrid-quantum-classical-computation">
<span id="id2"></span><h3>A Pragma-Based C Framework for Hybrid Quantum Classical Computation<a class="headerlink" href="#a-pragma-based-c-framework-for-hybrid-quantum-classical-computation" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://arxiv.org/abs/2309.02605">ArXiv</a></p>
<p><strong>Date de publication :</strong> 05/09/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Arnaud Gazda</p></li>
<li><p>Oceane Koska</p></li>
</ul>
<p><strong>Résumé :</strong>
Quantum computers promise exponential speed ups over classical computers for various tasks. This emerging technology is expected to have its first huge impact in High Performance Computing (HPC), as it can solve problems beyond the reach of HPC. To that end, HPC will require quantum accelerators, which will enable applications to run on both classical and quantum devices, via hybrid quantum-classical nodes. Hybrid quantum-HPC applications should be scalable, executable on Quantum Error Corrected (QEC) devices, and could use quantum-classical primitives. However, the lack of scalability, poor performances, and inability to insert classical schemes within quantum applications has prevented current quantum frameworks from being adopted by the HPC community.
This paper specifies the requirements of a hybrid quantum-classical framework compatible with HPC environments, and introduces a novel hardware-agnostic framework called Q-Pragma. This framework extends the classical programming language C++ heavily used in HPC via the addition of pragma directives to manage quantum computations.</p>
</section>
<section id="a-tree-approach-pauli-decomposition-algorithm-with-application-to-quantum-computing">
<span id="id3"></span><h3>A tree-approach Pauli decomposition algorithm with application to quantum computing<a class="headerlink" href="#a-tree-approach-pauli-decomposition-algorithm-with-application-to-quantum-computing" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://arxiv.org/abs/2403.11644">ArXiv</a></p>
<p><strong>Date de publication :</strong> 18/03/2024</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Oceane Koska</p></li>
<li><p>Marc Baboulin</p></li>
<li><p>Arnaud Gazda</p></li>
</ul>
<p><strong>Résumé :</strong>
The Pauli matrices are 2-by-2 matrices that are very useful in quantum computing. They can be used as elementary gates in quantum circuits but also to decompose any matrix of ℂ^2^n^×2^n^^ as a linear combination of tensor products of the Pauli matrices. However, the computational cost of this decomposition is potentially very expensive since it can be exponential in n. In this paper, we propose an algorithm with a parallel implementation that optimizes this decomposition using a tree approach to avoid redundancy in the computation while using a limited memory footprint. We also explain how some particular matrix structures can be exploited to reduce the number of operations. We provide numerical experiments to evaluate the sequential and parallel performance of our decomposition algorithm and we illustrate how this algorithm can be applied to encode matrices in a quantum memory.</p>
</section>
<section id="experimenting-with-hybrid-quantum-optimization-in-hpc-software-stack-for-cpu-register-allocation">
<span id="id4"></span><h3>Experimenting with hybrid quantum optimization in HPC software stack for CPU register allocation<a class="headerlink" href="#experimenting-with-hybrid-quantum-optimization-in-hpc-software-stack-for-cpu-register-allocation" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://universite-paris-saclay.hal.science/LISN/hal-04272048">HAL</a></p>
<p><strong>Date de publication :</strong> 11/09/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Brice Chichereau</p></li>
<li><p>Stéphane Vialle</p></li>
<li><p>Patrick Carribault</p></li>
</ul>
<p><strong>Résumé :</strong>
Quantum computers exploit the particular behavior of quantum physical systems to solve some problems in a different way than classical computers. We are now approaching the point where quantum computing could provide real advantages over classical methods. The computational capabilities of quantum systems will soon be available in future supercomputer architectures as hardware accelerators called Quantum Processing Units (QPU). From optimizing compilers to task scheduling, the High-Performance Computing (HPC) software stack could benefit from the advantages of quantum computing. We look here at the problem of register allocation, a crucial part of modern optimizing compilers. We propose a simple proofof-concept hybrid quantum algorithm based on QAOA to solve this problem. We implement the algorithm and integrate it directly into GCC, a well-known modern compiler. The performance of the algorithm is evaluated against the simple Chaitin-Briggs heuristic as well as GCC’s register allocator. While our proposed algorithm lags behind GCC’s modern heuristics, it is a good first step in the design of useful quantum algorithms for the classical HPC software stack.</p>
</section>
<section id="quantum-computing-with-and-for-many-body-physics">
<h3>Quantum computing with and for many-body physics<a class="headerlink" href="#quantum-computing-with-and-for-many-body-physics" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://arxiv.org/abs/2303.04850">ArXiv</a></p>
<p><strong>Date de publication :</strong> 08/03/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Thomas Ayral</p></li>
<li><p>Pauline Besserve</p></li>
<li><p>Denis Lacroix</p></li>
<li><p>Edgar Andres Ruiz Guzman</p></li>
</ul>
<p><strong>Résumé :</strong>
Quantum computing technologies are making steady progress. This has opened new opportunities for tackling problems whose complexity prevents their description on classical computers. A prototypical example of these complex problems are interacting quantum many-body systems: on the one hand, these systems are known to become rapidly prohibitive to describe using classical computers when their size increases. On the other hand, these systems are precisely those which are used in the laboratory to build quantum computing platforms. This arguably makes them one of the most promising early use cases of quantum computing. In this review, we explain how quantum many-body systems are used to build quantum processors, and how, in turn, current and future quantum processors can be used to describe large many-body systems of fermions such as electrons and nucleons. The review includes an introduction to analog and digital quantum devices, the mapping of Fermi systems and their Hamiltonians onto qubit registers, as well as an overview of methods to access their static and dynamical properties. We also highlight some aspects related to entanglement, and touch on the description, influence and processing of decoherence in quantum devices.</p>
</section>
</section>
<section id="langage-de-programmation">
<h2>Langage de programmation<a class="headerlink" href="#langage-de-programmation" title="Lien vers cette rubrique">#</a></h2>
<section id="a-programming-language-characterizing-quantum-polynomial-time">
<h3>A programming language characterizing quantum polynomial time<a class="headerlink" href="#a-programming-language-characterizing-quantum-polynomial-time" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2212.06656v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 13/12/2022</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Emmanuel Hainry</p></li>
<li><p>Romain Péchoux</p></li>
<li><p>Mário Silva</p></li>
</ul>
<p><strong>Résumé :</strong>
We introduce a first-order quantum programming language, named FOQ, whose
terminating programs are reversible. We restrict FOQ to a strict and tractable
subset, named PFOQ, of terminating programs with bounded width, that provides a
first programming language-based characterization of the quantum complexity
class FBQP. Finally, we present a tractable semantics-preserving algorithm
compiling a PFOQ program to a quantum circuit of size polynomial in the number
of input qubits.</p>
</section>
<section id="quantum-expectation-transformers-for-cost-analysis">
<span id="id5"></span><h3>Quantum Expectation Transformers for Cost Analysis<a class="headerlink" href="#quantum-expectation-transformers-for-cost-analysis" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2201.09361v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 23/01/2022</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Martin Avanzini</p></li>
<li><p>Georg Moser</p></li>
<li><p>Romain Péchoux</p></li>
<li><p>Simon Perdrix</p></li>
<li><p>Vladimir Zamdzhiev</p></li>
</ul>
<p><strong>Résumé :</strong>
We introduce a new kind of expectation transformer for a mixed
classical-quantum programming language. Our semantic approach relies on a new
notion of a cost structure, which we introduce and which can be seen as a
specialisation of the Kegelspitzen of Keimel and Plotkin. We show that our
weakest precondition analysis is both sound and adequate with respect to the
operational semantics of the language. Using the induced expectation
transformer, we provide formal analysis methods for the expected cost analysis
and expected value analysis of classical-quantum programs. We illustrate the
usefulness of our techniques by computing the expected cost of several
well-known quantum algorithms and protocols, such as coin tossing, repeat until
success, entangled state preparation, and quantum walks.</p>
</section>
<section id="qimaera-type-safe-variational-quantum-programming-in-idris">
<span id="id6"></span><h3>Qimaera: Type-safe (Variational) Quantum Programming in Idris<a class="headerlink" href="#qimaera-type-safe-variational-quantum-programming-in-idris" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2111.10867v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 21/11/2021</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Liliane-Joy Dandy</p></li>
<li><p>Emmanuel Jeandel</p></li>
<li><p>Vladimir Zamdzhiev</p></li>
</ul>
<p><strong>Résumé :</strong>
Variational Quantum Algorithms are hybrid classical-quantum algorithms where
classical and quantum computation work in tandem to solve computational
problems. These algorithms create interesting challenges for the design of
suitable programming languages. In this paper we introduce Qimaera, which is a
set of libraries for the Idris 2 programming language that enable the
programmer to implement (variational) quantum algorithms where the full power
of the elegant Idris language works in synchrony with quantum programming
primitives that we introduce. The two key ingredients of Idris that make this
possible are (1) dependent types which allow us to implement unitary (i.e.
reversible and controllable) quantum operations; and (2) linearity which allows
us to enforce fine-grained control over the execution of quantum operations
that ensures compliance with the laws of quantum mechanics. We demonstrate that
Qimaera is suitable for variational quantum programming by providing
implementations of the two most prominent variational quantum algorithms –
QAOA and VQE. To the best of our knowledge, this is the first implementation of
these algorithms that has been achieved in a type-safe framework.</p>
</section>
<section id="addition-and-differentiation-of-zx-diagrams">
<h3>Addition and Differentiation of ZX-diagrams<a class="headerlink" href="#addition-and-differentiation-of-zx-diagrams" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2202.11386v5">ArXiv</a></p>
<p><strong>Date de publication :</strong> 23/02/2022</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Emmanuel Jeandel</p></li>
<li><p>Simon Perdrix</p></li>
<li><p>Margarita Veshchezerova</p></li>
</ul>
<p><strong>Résumé :</strong>
The ZX-calculus is a powerful framework for reasoning in quantum computing.
It provides in particular a compact representation of matrices of interests. A
peculiar property of the ZX-calculus is the absence of a formal sum allowing
the linear combinations of arbitrary ZX-diagrams. The universality of the
formalism guarantees however that for any two ZX-diagrams, the sum of their
interpretations can be represented by a ZX-diagram. We introduce a general,
inductive definition of the addition of ZX-diagrams, relying on the
construction of controlled diagrams. Based on this addition technique, we
provide an inductive differentiation of ZX-diagrams.
Indeed, given a ZX-diagram with variables in the description of its angles,
one can differentiate the diagram according to one of these variables.
Differentiation is ubiquitous in quantum mechanics and quantum computing (e.g.
for solving optimization problems). Technically, differentiation of ZX-diagrams
is strongly related to summation as witnessed by the product rules.
We also introduce an alternative, non inductive, differentiation technique
rather based on the isolation of the variables. Finally, we apply our results
to deduce a diagram for an Ising Hamiltonian.</p>
</section>
<section id="lov-calculus-a-graphical-language-for-linear-optical-quantum-circuits">
<h3>LOv-Calculus: A Graphical Language for Linear Optical Quantum Circuits<a class="headerlink" href="#lov-calculus-a-graphical-language-for-linear-optical-quantum-circuits" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2204.11787v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 25/04/2022</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Alexandre Clément</p></li>
<li><p>Nicolas Heurtel</p></li>
<li><p>Shane Mansfield</p></li>
<li><p>Simon Perdrix</p></li>
<li><p>Benoît Valiron</p></li>
</ul>
<p><strong>Résumé :</strong>
We introduce the LOv-calculus, a graphical language for reasoning about
linear optical quantum circuits with so-called vacuum state auxiliary inputs.
We present the axiomatics of the language and prove its soundness and
completeness: two LOv-circuits represent the same quantum process if and only
if one can be transformed into the other with the rules of the LOv-calculus. We
give a confluent and terminating rewrite system to rewrite any
polarisation-preserving LOv-circuit into a unique triangular normal form,
inspired by the universal decomposition of Reck et al. (1994) for linear
optical quantum circuits.</p>
</section>
<section id="perceval-a-software-platform-for-discrete-variable-photonic-quantum-computing">
<h3>Perceval: A Software Platform for Discrete Variable Photonic Quantum Computing<a class="headerlink" href="#perceval-a-software-platform-for-discrete-variable-photonic-quantum-computing" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2204.00602v3">ArXiv</a></p>
<p><strong>Date de publication :</strong> 01/04/2022</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Nicolas Heurtel</p></li>
<li><p>Andreas Fyrillas</p></li>
<li><p>Grégoire de Gliniasty</p></li>
<li><p>Raphaël Le Bihan</p></li>
<li><p>Sébastien Malherbe</p></li>
<li><p>Marceau Pailhas</p></li>
<li><p>Eric Bertasi</p></li>
<li><p>Boris Bourdoncle</p></li>
<li><p>Pierre-Emmanuel Emeriau</p></li>
<li><p>Rawad Mezher</p></li>
<li><p>Luka Music</p></li>
<li><p>Nadia Belabas</p></li>
<li><p>Benoît Valiron</p></li>
<li><p>Pascale Senellart</p></li>
<li><p>Shane Mansfield</p></li>
<li><p>Jean Senellart</p></li>
</ul>
<p><strong>Résumé :</strong>
We introduce Perceval, an open-source software platform for simulating and
interfacing with discrete-variable photonic quantum computers, and describe its
main features and components. Its Python front-end allows photonic circuits to
be composed from basic photonic building blocks like photon sources, beam
splitters, phase-shifters and detectors. A variety of computational back-ends
are available and optimised for different use-cases. These use state-of-the-art
simulation techniques covering both weak simulation, or sampling, and strong
simulation. We give examples of Perceval in action by reproducing a variety of
photonic experiments and simulating photonic implementations of a range of
quantum algorithms, from Grover’s and Shor’s to examples of quantum machine
learning. Perceval is intended to be a useful toolkit for experimentalists
wishing to easily model, design, simulate, or optimise a discrete-variable
photonic experiment, for theoreticians wishing to design algorithms and
applications for discrete-variable photonic quantum computing platforms, and
for application designers wishing to evaluate algorithms on available
state-of-the-art photonic quantum computers.</p>
</section>
</section>
<section id="physique">
<h2>Physique<a class="headerlink" href="#physique" title="Lien vers cette rubrique">#</a></h2>
<section id="efficient-and-robust-estimation-of-many-qubit-hamiltonians">
<h3>Efficient and robust estimation of many-qubit Hamiltonians<a class="headerlink" href="#efficient-and-robust-estimation-of-many-qubit-hamiltonians" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2205.09567v2">ArXiv</a></p>
<p><strong>Date de publication :</strong> 19/05/2022</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Daniel Stilck França</p></li>
<li><p>Liubov A. Markovich</p></li>
<li><p>V. V. Dobrovitski</p></li>
<li><p>Albert H. Werner</p></li>
<li><p>Johannes Borregaard</p></li>
</ul>
<p><strong>Résumé :</strong>
Characterizing the interactions and dynamics of quantum mechanical systems is
an essential task in the development of quantum technologies. We propose an
efficient protocol based on the estimation of the time derivatives of few qubit
observables using polynomial interpolation for characterizing the underlying
Hamiltonian dynamics and Markovian noise of a multi-qubit device. For finite
range dynamics, our protocol exponentially relaxes the necessary time
resolution of the measurements and quadratically reduces the overall sample
complexity compared to previous approaches. Furthermore, we show that our
protocol can characterize the dynamics of systems with algebraically decaying
interactions. The implementation of the protocol requires only the preparation
of product states and single-qubit measurements. Furthermore, we develop a
shadow tomography method for quantum channels that is of independent interest.
This protocol can be used to parallelize to learn the Hamiltonian, rendering it
applicable for the characterization of both current and future quantum devices.</p>
</section>
<section id="efficient-learning-of-ground-thermal-states-within-phases-of-matter">
<h3>Efficient learning of ground &amp; thermal states within phases of matter<a class="headerlink" href="#efficient-learning-of-ground-thermal-states-within-phases-of-matter" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2301.12946v2">ArXiv</a></p>
<p><strong>Date de publication :</strong> 30/01/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Emilio Onorati</p></li>
<li><p>Cambyse Rouzé</p></li>
<li><p>Daniel Stilck França</p></li>
<li><p>James D. Watson</p></li>
</ul>
<p><strong>Résumé :</strong>
We consider two related tasks: (a) estimating a parameterisation of a given
Gibbs state and expectation values of Lipschitz observables on this state; and
(b) learning the expectation values of local observables within a thermal or
quantum phase of matter. In both cases, we wish to minimise the number of
samples we use to learn these properties to a given precision.
For the first task, we develop new techniques to learn parameterisations of
classes of systems, including quantum Gibbs states of non-commuting
Hamiltonians with exponential decay of correlations and the approximate Markov
property. We show it is possible to infer the expectation values of all
extensive properties of the state from a number of copies that not only scales
polylogarithmically with the system size, but polynomially in the observable’s
locality – an exponential improvement. This set of properties includes
expected values of quasi-local observables and entropies.
For the second task, we develop efficient algorithms for learning observables
in a phase of matter of a quantum system. By exploiting the locality of the
Hamiltonian, we show that <span class="math notranslate nohighlight">\(M\)</span> local observables can be learned with probability
<span class="math notranslate nohighlight">\(1-\delta\)</span> to precision <span class="math notranslate nohighlight">\(\epsilon\)</span> with using only
<span class="math notranslate nohighlight">\(N=O\big(\log\big(\frac{M}{\delta}\big)e^{polylog(\epsilon^{-1})}\big)\)</span> samples
– an exponential improvement on the precision over previous bounds. Our
results apply to both families of ground states of Hamiltonians displaying
local topological quantum order, and thermal phases of matter with exponential
decay of correlations. In addition, our sample complexity applies to the worse
case setting whereas previous results only applied on average.
Furthermore, we develop tools of independent interest, such as robust shadow
tomography algorithms, Gibbs approximations to ground states, and
generalisations of transportation cost inequalities for Gibbs states.</p>
</section>
<section id="provably-efficient-learning-of-phases-of-matter-via-dissipative-evolutions">
<span id="id7"></span><h3>Provably Efficient Learning of Phases of Matter via Dissipative Evolutions<a class="headerlink" href="#provably-efficient-learning-of-phases-of-matter-via-dissipative-evolutions" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2311.07506v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 13/11/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Emilio Onorati</p></li>
<li><p>Cambyse Rouzé</p></li>
<li><p>Daniel Stilck França</p></li>
<li><p>James D. Watson</p></li>
</ul>
<p><strong>Résumé :</strong>
The combination of quantum many-body and machine learning techniques has
recently proved to be a fertile ground for new developments in quantum
computing. Several works have shown that it is possible to classically
efficiently predict the expectation values of local observables on all states
within a phase of matter using a machine learning algorithm after learning from
data obtained from other states in the same phase. However, existing results
are restricted to phases of matter such as ground states of gapped Hamiltonians
and Gibbs states that exhibit exponential decay of correlations. In this work,
we drop this requirement and show how it is possible to learn local expectation
values for all states in a phase, where we adopt the Lindbladian phase
definition by Coser &amp; P’erez-Garc’ia [Coser &amp; P’erez-Garc’ia, Quantum 3,
174 (2019)], which defines states to be in the same phase if we can drive one
to other rapidly with a local Lindbladian. This definition encompasses the
better-known Hamiltonian definition of phase of matter for gapped ground state
phases, and further applies to any family of states connected by short unitary
circuits, as well as non-equilibrium phases of matter, and those stable under
external dissipative interactions. Under this definition, we show that <span class="math notranslate nohighlight">\(N =
O(\log(n/\delta)2^{polylog(1/\epsilon)})\)</span> samples suffice to learn local
expectation values within a phase for a system with <span class="math notranslate nohighlight">\(n\)</span> qubits, to error
<span class="math notranslate nohighlight">\(\epsilon\)</span> with failure probability <span class="math notranslate nohighlight">\(\delta\)</span>. This sample complexity is
comparable to previous results on learning gapped and thermal phases, and it
encompasses previous results of this nature in a unified way. Furthermore, we
also show that we can learn families of states which go beyond the Lindbladian
definition of phase, and we derive bounds on the sample complexity which are
dependent on the mixing time between states under a Lindbladian evolution.</p>
</section>
<section id="many-body-entropies-and-entanglement-from-polynomially-many-local-measurements">
<span id="id8"></span><h3>Many-body entropies and entanglement from polynomially-many local measurements<a class="headerlink" href="#many-body-entropies-and-entanglement-from-polynomially-many-local-measurements" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2311.08108v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 14/11/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Benoît Vermersch</p></li>
<li><p>Marko Ljubotina</p></li>
<li><p>J. Ignacio Cirac</p></li>
<li><p>Peter Zoller</p></li>
<li><p>Maksym Serbyn</p></li>
<li><p>Lorenzo Piroli</p></li>
</ul>
<p><strong>Résumé :</strong>
Randomized measurements (RMs) provide a practical scheme to probe complex
many-body quantum systems. While they are a very powerful tool to extract local
information, global properties such as entropy or bipartite entanglement remain
hard to probe, requiring a number of measurements or classical post-processing
resources growing exponentially in the system size. In this work, we address
the problem of estimating global entropies and mixed-state entanglement via
partial-transposed (PT) moments, and show that efficient estimation strategies
exist under the assumption that all the spatial correlation lengths are finite.
Focusing on one-dimensional systems, we identify a set of approximate
factorization conditions (AFCs) on the system density matrix which allow us to
reconstruct entropies and PT moments from information on local subsystems.
Combined with the RM toolbox, this yields a simple strategy for entropy and
entanglement estimation which is provably accurate assuming that the state to
be measured satisfies the AFCs, and which only requires polynomially-many
measurements and post-processing operations. We prove that the AFCs hold for
finite-depth quantum-circuit states and translation-invariant matrix-product
density operators, and provide numerical evidence that they are satisfied in
more general, physically-interesting cases, including thermal states of local
Hamiltonians. We argue that our method could be practically useful to detect
bipartite mixed-state entanglement for large numbers of qubits available in
today’s quantum platforms.</p>
</section>
</section>
<section id="chimie">
<h2>Chimie<a class="headerlink" href="#chimie" title="Lien vers cette rubrique">#</a></h2>
<section id="greedy-gradient-free-adaptive-variational-quantum-algorithms-on-a-noisy-intermediate-scale-quantum-computer">
<span id="id9"></span><h3>Greedy Gradient-free Adaptive Variational Quantum Algorithms on a Noisy Intermediate Scale Quantum Computer<a class="headerlink" href="#greedy-gradient-free-adaptive-variational-quantum-algorithms-on-a-noisy-intermediate-scale-quantum-computer" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://arxiv.org/abs/2306.17159">ArXiv</a></p>
<p><strong>Date de publication :</strong> 29/06/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>César Feniou</p></li>
<li><p>Baptiste Claudon</p></li>
<li><p>Muhammad Hassan</p></li>
<li><p>Axel Courtat</p></li>
<li><p>Olivier Adjoua</p></li>
<li><p>Yvon Maday</p></li>
<li><p>Jean-Philip Piquemal</p></li>
</ul>
<p><strong>Résumé :</strong>
Hybrid quantum-classical adaptive Variational Quantum Eigensolvers (VQE) already hold the potential to outperform classical computing for simulating quantum many-body systems. However, their practical implementation on current quantum processing units (QPUs) is very challenging due to the noisy evaluation of a polynomially scaling number of observables, undertaken for operator selection and optimisation of a high-dimensional cost function. To overcome this, we propose new techniques to execute adaptive algorithms on a 25-qubit error-mitigated QPU coupled to a GPU-accelerated HPC simulator. Targeting physics applications, we compute the ground state of a 25-body Ising model using the newly introduced Greedy Gradient-free Adaptive VQE (CGA-VQE) requiring only five circuit measurements per iteration, regardless of the number of qubits and size of the operator pool. Towards chemistry, we combine the GGA-VQE and Overlap-ADAPT-VQE algorithms to approximate a molecular system ground state. We show that the QPU successfully executes the algorithms and yields the correct choice of parametrised unitary operators. While the QPU evaluation of the resulting ansatz wave-function is polluted by hardware noise, a single final evaluation of the sought-after observables on a classical GPU-accelerated/noiseless simulator allows the recovery of the correct approximation of the ground state, thus highlighting the need for hybrid quantum-classical observable measurement.</p>
</section>
<section id="overlap-adapt-vqe-practical-quantum-chemistry-on-quantum-computers-via-overlap-guided-compact-ansatze">
<span id="id10"></span><h3>Overlap-ADAPT-VQE: Practical Quantum Chemistry on Quantum Computers via Overlap-Guided Compact Ansätze<a class="headerlink" href="#overlap-adapt-vqe-practical-quantum-chemistry-on-quantum-computers-via-overlap-guided-compact-ansatze" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://arxiv.org/abs/2301.10196">ArXiv</a></p>
<p><strong>Date de publication :</strong> 24/01/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>César Feniou</p></li>
<li><p>Muhammad Hassan</p></li>
<li><p>Diata Traoré</p></li>
<li><p>Emmanuel Giner</p></li>
<li><p>Yvon Maday</p></li>
<li><p>Jean-Philip Piquemal</p></li>
</ul>
<p><strong>Résumé :</strong>
ADAPT-VQE is a robust algorithm for hybrid quantum-classical simulations of quantum chemical systems on near-term quantum computers. While its iterative process systematically reaches the ground state energy, ADAPT-VQE is sensitive to local energy minima, leading to over-parameterized ansätze. We introduce the Overlap-ADAPT-VQE to grow wave-functions by maximizing their overlap with any intermediate target wave-function that already captures some electronic correlation. By avoiding building the ansatz in the energy landscape strewn with local minima, the Overlap-ADAPT-VQE produces ultra-compact ansätze suitable for high-accuracy initializations of a new ADAPT procedure. Spectacular advantages over ADAPT-VQE are observed for strongly correlated systems including massive savings in circuit depth. Since this compression strategy can also be initialized with accurate Selected-Configuration Interaction (SCI) classical target wave-functions, it paves the way for chemically accurate simulations of larger systems, and strengthens the promise of decisively surpassing classical quantum chemistry through the power of quantum computing.</p>
</section>
<section id="sparse-quantum-state-preparation-for-strongly-correlated-systems">
<span id="id11"></span><h3>Sparse Quantum State Preparation for Strongly Correlated Systems<a class="headerlink" href="#sparse-quantum-state-preparation-for-strongly-correlated-systems" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://arxiv.org/abs/2311.03347">ArXiv</a></p>
<p><strong>Date de publication :</strong> 06/11/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>César Feniou</p></li>
<li><p>Olivier Adjoua</p></li>
<li><p>Baptiste Claudon</p></li>
<li><p>Julien Zylberman</p></li>
<li><p>Emmanuel Giner</p></li>
<li><p>Jean-Philip Piquemal</p></li>
</ul>
<p><strong>Résumé :</strong>
Quantum Computing allows, in principle, the encoding of the exponentially scaling many-electron wave function onto a linearly scaling qubit register, offering a promising solution to overcome the limitations of traditional quantum chemistry methods. An essential requirement for ground state quantum algorithms to be practical is the initialisation of the qubits to a high-quality approximation of the sought-after ground state. Quantum State Preparation (QSP) allows the preparation of approximate eigenstates obtained from classical calculations, but it is frequently treated as an oracle in quantum information. In this study, we conduct QSP on the ground state of prototypical strongly correlated systems, up to 28 qubits, using the Hyperion GPU-accelerated state-vector emulator. Various variational and non-variational methods are compared in terms of their circuit depth and classical complexity. Our results indicate that the recently developed Overlap-ADAPT-VQE algorithm offers the most advantageous performance for near-term applications.</p>
</section>
<section id="dilute-measurement-induced-cooling-into-many-body-ground-states">
<h3>Dilute measurement-induced cooling into many-body ground states<a class="headerlink" href="#dilute-measurement-induced-cooling-into-many-body-ground-states" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://arxiv.org/abs/2311.05258">ArXiv</a></p>
<p><strong>Date de publication :</strong> 09/11/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Josias Langbehn</p></li>
<li><p>Kyrylo Snizhko</p></li>
<li><p>Igor Gornyi</p></li>
<li><p>Giovanna Morigi</p></li>
<li><p>Yuval Gefen</p></li>
<li><p>Christiane P. Koch</p></li>
</ul>
<p><strong>Résumé :</strong>
Cooling a quantum system to its ground state is important for the characterization of non-trivial interacting systems, and in the context of a variety of quantum information platforms. In principle, this can be achieved by employing measurement-based passive steering protocols, where the steering steps are predetermined and are not based on measurement readouts. However, measurements, i.e., coupling the system to auxiliary quantum degrees of freedom, is rather costly, and protocols in which the number of measurements scales with system size will have limited practical applicability. Here, we identify conditions under which measurement-based cooling protocols can be taken to the dilute limit. For two examples of frustration-free one-dimensional spin chains, we show that steering on a single link is sufficient to cool these systems into their unique ground states. We corroborate our analytical arguments with finite-size numerical simulations and discuss further applications.</p>
</section>
</section>
<section id="machine-learning-optimisation">
<h2>Machine learning/optimisation<a class="headerlink" href="#machine-learning-optimisation" title="Lien vers cette rubrique">#</a></h2>
<section id="trainability-and-expressivity-of-hamming-weight-preserving-quantum-circuits-for-machine-learning">
<span id="id12"></span><h3>Trainability and Expressivity of Hamming-Weight Preserving Quantum Circuits for Machine Learning<a class="headerlink" href="#trainability-and-expressivity-of-hamming-weight-preserving-quantum-circuits-for-machine-learning" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2309.15547v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 27/09/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Léo Monbroussou</p></li>
<li><p>Jonas Landman</p></li>
<li><p>Alex B. Grilo</p></li>
<li><p>Romain Kukla</p></li>
<li><p>Elham Kashefi</p></li>
</ul>
<p><strong>Résumé :</strong>
Quantum machine learning has become a promising area for real world
applications of quantum computers, but near-term methods and their scalability
are still important research topics. In this context, we analyze the
trainability and controllability of specific Hamming weight preserving quantum
circuits. These circuits use gates that preserve subspaces of the Hilbert
space, spanned by basis states with fixed Hamming weight <span class="math notranslate nohighlight">\(k\)</span>. They are good
candidates for mimicking neural networks, by both loading classical data and
performing trainable layers. In this work, we first design and prove the
feasibility of new heuristic data loaders, performing quantum amplitude
encoding of <span class="math notranslate nohighlight">\(\binom{n}{k}\)</span>-dimensional vectors by training a n-qubit quantum
circuit. Then, we analyze more generally the trainability of Hamming weight
preserving circuits, and show that the variance of their gradients is bounded
according to the size of the preserved subspace. This proves the conditions of
existence of Barren Plateaus for these circuits, and highlights a setting where
a recent conjecture on the link between controllability and trainability of
variational quantum circuits does not apply.</p>
</section>
<section id="solving-higher-order-binary-optimization-problems-on-nisq-devices-experiments-and-limitations">
<h3>Solving Higher Order Binary Optimization Problems on NISQ Devices: Experiments and Limitations<a class="headerlink" href="#solving-higher-order-binary-optimization-problems-on-nisq-devices-experiments-and-limitations" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://www.iccs-meeting.org/archive/iccs2023/papers/140770216.pdf">iccs</a></p>
<p><strong>Date de publication :</strong> 26/06/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Valentin Gilbert</p></li>
<li><p>Julien Rodriguez</p></li>
<li><p>Stephane Louise</p></li>
<li><p>Renaud Sirdey</p></li>
</ul>
<p><strong>Résumé :</strong>
With the recent availability of Noisy Intermediate-Scale Quantum devices, the potential of quantum computers to impact the field of
combinatorial optimization lies in quantum variational and annealing-based
methods. This paper further compares Quantum Annealing (QA) and the
Quantum Approximate Optimization Algorithm (QAOA) in solving Higher
Order Binary Optimization (HOBO) problems. This case study considers the
hypergraph partitioning problem, which is used to generate custom HOBO
problems. Our experiments show that D-Wave systems quickly reach limits
solving dense HOBO problems. Although the QAOA demonstrates better
performance on exact simulations, noisy simulations reveal that the gate
error rate should remain under 10<sup>-5</sup> to match D-Wave systems’ performance,
considering equal compilation overheads for both device.</p>
</section>
</section>
<section id="cryptographie-cryptanalyse">
<h2>Cryptographie/cryptanalyse<a class="headerlink" href="#cryptographie-cryptanalyse" title="Lien vers cette rubrique">#</a></h2>
<section id="variational-loop-vertex-expansion">
<h3>Variational Loop Vertex Expansion<a class="headerlink" href="#variational-loop-vertex-expansion" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2312.00712v2">ArXiv</a></p>
<p><strong>Date de publication :</strong> 01/12/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Vasily Sazonov</p></li>
</ul>
<p><strong>Résumé :</strong>
Loop Vertex Expansion (LVE) was developed to construct QFT models with local
and non-local interactions. Using LVE, one can prove the analyticity in the
finite cardioid-like domain in the complex plain of the coupling constant of
the free energies and cumulants of various vector, matrix, or tensor-type
models. Here, applying the idea of choosing the initial approximation depending
on the coupling constant, we construct the analytic continuation of the free
energy of the quartic matrix model beyond the standard LVE cardioid over the
branch cut and for arbitrary large couplings.</p>
</section>
<section id="even-cycle-detection-in-the-randomized-and-quantum-congest-model">
<h3>Even-Cycle Detection in the Randomized and Quantum CONGEST Model<a class="headerlink" href="#even-cycle-detection-in-the-randomized-and-quantum-congest-model" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2402.12018v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 19/02/2024</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Pierre Fraigniaud</p></li>
<li><p>Mael Luce</p></li>
<li><p>Frederic Magniez</p></li>
<li><p>Ioan Todinca</p></li>
</ul>
<p><strong>Résumé :</strong>
We show that, for every <span class="math notranslate nohighlight">\(k\geq 2\)</span>, <span class="math notranslate nohighlight">\(C_{2k}\)</span>-freeness can be decided in
<span class="math notranslate nohighlight">\(O(n^{1-1/k})\)</span> rounds in the \CONGEST{} model by a randomized Monte-Carlo
distributed algorithm with one-sided error probability <span class="math notranslate nohighlight">\(1/3\)</span>. This matches the
best round-complexities of previously known algorithms for <span class="math notranslate nohighlight">\(k\in\{2,3,4,5\}\)</span> by
Drucker et al. [PODC’14] and Censor-Hillel et al. [DISC’20], but improves the
complexities of the known algorithms for <span class="math notranslate nohighlight">\(k&gt;5\)</span> by Eden et al. [DISC’19], which
were essentially of the form <span class="math notranslate nohighlight">\(\tilde O(n^{1-2/k^2})\)</span>. Our algorithm uses
colored BFS-explorations with threshold, but with an original \emph{global}
approach that enables to overcome a recent impossibility result by Fraigniaud
et al. [SIROCCO’23] about using colored BFS-exploration with \emph{local}
threshold for detecting cycles.
We also show how to quantize our algorithm for achieving a round-complexity
<span class="math notranslate nohighlight">\(\tilde O(n^{\frac{1}{2}-\frac{1}{2k}})\)</span> in the quantum setting for deciding
<span class="math notranslate nohighlight">\(C_{2k}\)</span> freeness. Furthermore, this allows us to improve the known quantum
complexities of the simpler problem of detecting cycles of length \emph{at
most}~<span class="math notranslate nohighlight">\(2k\)</span> by van Apeldoorn and de Vos [PODC’22]. Our quantization is in two
steps. First, the congestion of our randomized algorithm is reduced, to the
cost of reducing its success probability too. Second, the success probability
is boosted using a new quantum framework derived from sequential algorithms,
namely Monte-Carlo quantum amplification.</p>
</section>
<section id="a-functional-analysis-approach-to-symbolic-regression">
<h3>A Functional Analysis Approach to Symbolic Regression<a class="headerlink" href="#a-functional-analysis-approach-to-symbolic-regression" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2402.06299v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 09/02/2024</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Kirill Antonov</p></li>
<li><p>Roman Kalkreuth</p></li>
<li><p>Kaifeng Yang</p></li>
<li><p>Thomas Bäck</p></li>
<li><p>Niki van Stein</p></li>
<li><p>Anna V Kononova</p></li>
</ul>
<p><strong>Résumé :</strong>
Symbolic regression (SR) poses a significant challenge for randomized search
heuristics due to its reliance on the synthesis of expressions for input-output
mappings. Although traditional genetic programming (GP) algorithms have
achieved success in various domains, they exhibit limited performance when
tree-based representations are used for SR. To address these limitations, we
introduce a novel SR approach called Fourier Tree Growing (FTG) that draws
insights from functional analysis. This new perspective enables us to perform
optimization directly in a different space, thus avoiding intricate symbolic
expressions. Our proposed algorithm exhibits significant performance
improvements over traditional GP methods on a range of classical
one-dimensional benchmarking problems. To identify and explain limiting factors
of GP and FTG, we perform experiments on a large-scale polynomials benchmark
with high-order polynomials up to degree 100. To the best of the authors”
knowledge, this work represents the pioneering application of functional
analysis in addressing SR problems. The superior performance of the proposed
algorithm and insights into the limitations of GP open the way for further
advancing GP for SR and related areas of explainable machine learning.</p>
</section>
<section id="quantum-complexity-of-testing-signed-graph-clusterability">
<h3>(Quantum) complexity of testing signed graph clusterability<a class="headerlink" href="#quantum-complexity-of-testing-signed-graph-clusterability" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2311.10480v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 17/11/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Kuo-Chin Chen</p></li>
<li><p>Simon Apers</p></li>
<li><p>Min-Hsiu Hsieh</p></li>
</ul>
<p><strong>Résumé :</strong>
This study examines clusterability testing for a signed graph in the
bounded-degree model. Our contributions are two-fold. First, we provide a
quantum algorithm with query complexity <span class="math notranslate nohighlight">\(\tilde{O}(N^{1/3})\)</span> for testing
clusterability, which yields a polynomial speedup over the best classical
clusterability tester known [arXiv:2102.07587]. Second, we prove an
<span class="math notranslate nohighlight">\(\tilde{\Omega}(\sqrt{N})\)</span> classical query lower bound for testing
clusterability, which nearly matches the upper bound from [arXiv:2102.07587].
This settles the classical query complexity of clusterability testing, and it
shows that our quantum algorithm has an advantage over any classical algorithm.</p>
</section>
<section id="quantum-speedups-for-linear-programming-via-interior-point-methods">
<h3>Quantum speedups for linear programming via interior point methods<a class="headerlink" href="#quantum-speedups-for-linear-programming-via-interior-point-methods" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2311.03215v2">ArXiv</a></p>
<p><strong>Date de publication :</strong> 06/11/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Simon Apers</p></li>
<li><p>Sander Gribling</p></li>
</ul>
<p><strong>Résumé :</strong>
We describe a quantum algorithm based on an interior point method for solving
a linear program with <span class="math notranslate nohighlight">\(n\)</span> inequality constraints on <span class="math notranslate nohighlight">\(d\)</span> variables. The
algorithm explicitly returns a feasible solution that is <span class="math notranslate nohighlight">\(\varepsilon\)</span>-close to
optimal, and runs in time <span class="math notranslate nohighlight">\(\sqrt{n} \cdot
\mathrm{poly}(d,\log(n),\log(1/\varepsilon))\)</span> which is sublinear for tall
linear programs (i.e., <span class="math notranslate nohighlight">\(n \gg d\)</span>). Our algorithm speeds up the Newton step in
the state-of-the-art interior point method of Lee and Sidford [FOCS~”14]. This
requires us to efficiently approximate the Hessian and gradient of the barrier
function, and these are our main contributions.
To approximate the Hessian, we describe a quantum algorithm for the
\emph{spectral approximation} of <span class="math notranslate nohighlight">\(A^T A\)</span> for a tall matrix <span class="math notranslate nohighlight">\(A \in \mathbb R^{n
\times d}\)</span>. The algorithm uses leverage score sampling in combination with
Grover search, and returns a <span class="math notranslate nohighlight">\(\delta\)</span>-approximation by making
<span class="math notranslate nohighlight">\(O(\sqrt{nd}/\delta)\)</span> row queries to <span class="math notranslate nohighlight">\(A\)</span>. This generalizes an earlier quantum
speedup for graph sparsification by Apers and de Wolf~[FOCS~”20]. To
approximate the gradient, we use a recent quantum algorithm for multivariate
mean estimation by Cornelissen, Hamoudi and Jerbi [STOC “22]. While a naive
implementation introduces a dependence on the condition number of the Hessian,
we avoid this by pre-conditioning our random variable using our quantum
algorithm for spectral approximation.</p>
</section>
<section id="quantum-walks-the-discrete-wave-equation-and-chebyshev-polynomials">
<h3>Quantum walks, the discrete wave equation and Chebyshev polynomials<a class="headerlink" href="#quantum-walks-the-discrete-wave-equation-and-chebyshev-polynomials" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2402.07809v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 12/02/2024</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Simon Apers</p></li>
<li><p>Laurent Miclo</p></li>
</ul>
<p><strong>Résumé :</strong>
A quantum walk is the quantum analogue of a random walk. While it is
relatively well understood how quantum walks can speed up random walk hitting
times, it is a long-standing open question to what extent quantum walks can
speed up the spreading or mixing rate of random walks on graphs. In this
expository paper, inspired by a blog post by Terence Tao, we describe a
particular perspective on this question that derives quantum walks from the
discrete wave equation on graphs. This yields a description of the quantum walk
dynamics as simply applying a Chebyshev polynomial to the random walk
transition matrix. This perspective decouples the problem from its quantum
origin, and highlights connections to earlier (non-quantum) work and the use of
Chebyshev polynomials in random walk theory as in the Varopoulos-Carne bound.
We illustrate the approach by proving a weak limit of the quantum walk dynamics
on the lattice. This gives a different proof of the quadratically improved
spreading behavior of quantum walks on lattices.</p>
</section>
<section id="quantum-security-of-subset-cover-problems">
<h3>Quantum security of subset cover problems<a class="headerlink" href="#quantum-security-of-subset-cover-problems" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2210.15396v2">ArXiv</a></p>
<p><strong>Date de publication :</strong> 27/10/2022</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Samuel Bouaziz–Ermann</p></li>
<li><p>Alex B. Grilo</p></li>
<li><p>Damien Vergnaud</p></li>
</ul>
<p><strong>Résumé :</strong>
The subset cover problem for <span class="math notranslate nohighlight">\(k \geq 1\)</span> hash functions, which can be seen as
an extension of the collision problem, was introduced in 2002 by Reyzin and
Reyzin to analyse the security of their hash-function based signature scheme
HORS.
The security of many hash-based signature schemes relies on this problem or a
variant of this problem (e.g. HORS, SPHINCS, SPHINCS+, <span class="math notranslate nohighlight">\(\dots\)</span>).
Recently, Yuan, Tibouchi and Abe (2022) introduced a variant to the subset
cover problem, called restricted subset cover, and proposed a quantum algorithm
for this problem. In this work, we prove that any quantum algorithm needs to
make <span class="math notranslate nohighlight">\(\Omega\left((k+1)^{-\frac{2^{k}}{2^{k+1}-1}}\cdot
N^{\frac{2^{k}-1}{2^{k+1}-1}}\right)\)</span> queries to the underlying hash functions
with codomain size <span class="math notranslate nohighlight">\(N\)</span> to solve the restricted subset cover problem, which
essentially matches the query complexity of the algorithm proposed by Yuan,
Tibouchi and Abe.
We also analyze the security of the general <span class="math notranslate nohighlight">\((r,k)\)</span>-subset cover problem,
which is the underlying problem that implies the unforgeability of HORS under a
<span class="math notranslate nohighlight">\(r\)</span>-chosen message attack (for <span class="math notranslate nohighlight">\(r \geq 1\)</span>). We prove that a generic quantum
algorithm needs to make <span class="math notranslate nohighlight">\(\Omega\left(N^{k/5}\right)\)</span> queries to the underlying
hash functions to find a <span class="math notranslate nohighlight">\((1,k)\)</span>-subset cover.
We also propose a quantum algorithm that finds a <span class="math notranslate nohighlight">\((r,k)\)</span>-subset cover making
<span class="math notranslate nohighlight">\(O\left(N^{k/(2+2r)}\right)\)</span> queries to the <span class="math notranslate nohighlight">\(k\)</span> hash functions.</p>
</section>
<section id="the-special-case-of-cyclotomic-fields-in-quantum-algorithms-for-unit-groups">
<h3>The special case of cyclotomic fields in quantum algorithms for unit groups<a class="headerlink" href="#the-special-case-of-cyclotomic-fields-in-quantum-algorithms-for-unit-groups" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2303.03978v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 07/03/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Razvan Barbulescu</p></li>
<li><p>Adrien Poulalion</p></li>
</ul>
<p><strong>Résumé :</strong>
Unit group computations are a cryptographic primitive for which one has a
fast quantum algorithm, but the required number of qubits is <span class="math notranslate nohighlight">\(\tilde O(m^5)\)</span>.
In this work we propose a modification of the algorithm for which the number of
qubits is <span class="math notranslate nohighlight">\(\tilde O(m^2)\)</span> in the case of cyclotomic fields. Moreover, under a
recent conjecture on the size of the class group of <span class="math notranslate nohighlight">\(\mathbb{Q}(\zeta_m +
\zeta_m^{-1})\)</span>, the quantum algorithms is much simpler because it is a hidden
subgroup problem (HSP) algorithm rather than its error estimation counterpart:
continuous hidden subgroup problem (CHSP). We also discuss the (minor) speed-up
obtained when exploiting Galois automorphisms thanks to the Buchmann-Pohst
algorithm over <span class="math notranslate nohighlight">\(\mathcal{O}_K\)</span>-lattices.</p>
</section>
</section>
<section id="caracterisation-correction-d-erreur">
<h2>Caractérisation/correction d’erreur<a class="headerlink" href="#caracterisation-correction-d-erreur" title="Lien vers cette rubrique">#</a></h2>
<section id="efficient-learning-of-the-structure-and-parameters-of-local-pauli-noise-channels">
<h3>Efficient learning of the structure and parameters of local Pauli noise channels<a class="headerlink" href="#efficient-learning-of-the-structure-and-parameters-of-local-pauli-noise-channels" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2307.02959v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 06/07/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Cambyse Rouzé</p></li>
<li><p>Daniel Stilck França</p></li>
</ul>
<p><strong>Résumé :</strong>
The unavoidable presence of noise is a crucial roadblock for the development
of large-scale quantum computers and the ability to characterize quantum noise
reliably and efficiently with high precision is essential to scale quantum
technologies further. Although estimating an arbitrary quantum channel requires
exponential resources, it is expected that physically relevant noise has some
underlying local structure, for instance that errors across different qubits
have a conditional independence structure. Previous works showed how it is
possible to estimate Pauli noise channels with an efficient number of samples
in a way that is robust to state preparation and measurement errors, albeit
departing from a known conditional independence structure.
We present a novel approach for learning Pauli noise channels over n qubits
that addresses this shortcoming. Unlike previous works that focused on learning
coefficients with a known conditional independence structure, our method learns
both the coefficients and the underlying structure. We achieve our results by
leveraging a groundbreaking result by Bresler for efficiently learning Gibbs
measures and obtain an optimal sample complexity of O(log(n)) to learn the
unknown structure of the noise acting on n qubits. This information can then be
leveraged to obtain a description of the channel that is close in diamond
distance from O(poly(n)) samples. Furthermore, our method is efficient both in
the number of samples and postprocessing without giving up on other desirable
features such as SPAM-robustness, and only requires the implementation of
single qubit Cliffords. In light of this, our novel approach enables the
large-scale characterization of Pauli noise in quantum devices under minimal
experimental requirements and assumptions.</p>
</section>
<section id="information-theoretic-generalization-bounds-for-learning-from-quantum-data">
<span id="id13"></span><h3>Information-theoretic generalization bounds for learning from quantum data<a class="headerlink" href="#information-theoretic-generalization-bounds-for-learning-from-quantum-data" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2311.05529v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 09/11/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Matthias Caro</p></li>
<li><p>Tom Gur</p></li>
<li><p>Cambyse Rouzé</p></li>
<li><p>Daniel Stilck França</p></li>
<li><p>Sathyawageeswar Subramanian</p></li>
</ul>
<p><strong>Résumé :</strong>
Learning tasks play an increasingly prominent role in quantum information and
computation. They range from fundamental problems such as state discrimination
and metrology over the framework of quantum probably approximately correct
(PAC) learning, to the recently proposed shadow variants of state tomography.
However, the many directions of quantum learning theory have so far evolved
separately. We propose a general mathematical formalism for describing quantum
learning by training on classical-quantum data and then testing how well the
learned hypothesis generalizes to new data. In this framework, we prove bounds
on the expected generalization error of a quantum learner in terms of classical
and quantum information-theoretic quantities measuring how strongly the
learner’s hypothesis depends on the specific data seen during training.
To achieve this, we use tools from quantum optimal transport and quantum
concentration inequalities to establish non-commutative versions of decoupling
lemmas that underlie recent information-theoretic generalization bounds for
classical machine learning.
Our framework encompasses and gives intuitively accessible generalization
bounds for a variety of quantum learning scenarios such as quantum state
discrimination, PAC learning quantum states, quantum parameter estimation, and
quantumly PAC learning classical functions. Thereby, our work lays a foundation
for a unifying quantum information-theoretic perspective on quantum learning.</p>
</section>
<section id="lower-bounds-on-learning-pauli-channels">
<h3>Lower Bounds on Learning Pauli Channels<a class="headerlink" href="#lower-bounds-on-learning-pauli-channels" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2301.09192v1">ArXiv</a></p>
<p><strong>Date de publication :</strong> 22/01/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Omar Fawzi</p></li>
<li><p>Aadil Oufkir</p></li>
<li><p>Daniel Stilck França</p></li>
</ul>
<p><strong>Résumé :</strong>
Understanding the noise affecting a quantum device is of fundamental
importance for scaling quantum technologies. A particularly important class of
noise models is that of Pauli channels, as randomized compiling techniques can
effectively bring any quantum channel to this form and are significantly more
structured than general quantum channels. In this paper, we show fundamental
lower bounds on the sample complexity for learning Pauli channels in diamond
norm with unentangled measurements. We consider both adaptive and non-adaptive
strategies. In the non-adaptive setting, we show a lower bound of
<span class="math notranslate nohighlight">\(\Omega(2^{3n}\epsilon^{-2})\)</span> to learn an <span class="math notranslate nohighlight">\(n\)</span>-qubit Pauli channel. In
particular, this shows that the recently introduced learning procedure by
Flammia and Wallman is essentially optimal. In the adaptive setting, we show a
lower bound of <span class="math notranslate nohighlight">\(\Omega(2^{2.5n}\epsilon^{-2})\)</span> for
<span class="math notranslate nohighlight">\(\epsilon=\mathcal{O}(2^{-n})\)</span>, and a lower bound of
<span class="math notranslate nohighlight">\(\Omega(2^{2n}\epsilon^{-2} )\)</span> for any <span class="math notranslate nohighlight">\(\epsilon &gt; 0\)</span>. This last lower bound
even applies for arbitrarily many sequential uses of the channel, as long as
they are only interspersed with other unital operations.</p>
</section>
<section id="robust-sparse-iqp-sampling-in-constant-depth">
<span id="id14"></span><h3>Robust sparse IQP sampling in constant depth<a class="headerlink" href="#robust-sparse-iqp-sampling-in-constant-depth" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="http://arxiv.org/abs/2307.10729v4">ArXiv</a></p>
<p><strong>Date de publication :</strong> 20/07/2023</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Louis Paletta</p></li>
<li><p>Anthony Leverrier</p></li>
<li><p>Alain Sarlette</p></li>
<li><p>Mazyar Mirrahimi</p></li>
<li><p>Christophe Vuillot</p></li>
</ul>
<p><strong>Résumé :</strong>
Between NISQ (noisy intermediate scale quantum) approaches without any proof
of robust quantum advantage and fully fault-tolerant quantum computation, we
propose a scheme to achieve a provable superpolynomial quantum advantage (under
some widely accepted complexity conjectures) that is robust to noise with
minimal error correction requirements. We choose a class of sampling problems
with commuting gates known as sparse IQP (Instantaneous Quantum
Polynomial-time) circuits and we ensure its fault-tolerant implementation by
introducing the tetrahelix code. This new code is obtained by merging several
tetrahedral codes (3D color codes) and has the following properties: each
sparse IQP gate admits a transversal implementation, and the depth of the
logical circuit can be traded for its width. Combining those, we obtain a
depth-1 implementation of any sparse IQP circuit up to the preparation of
encoded states. This comes at the cost of a space overhead which is only
polylogarithmic in the width of the original circuit. We furthermore show that
the state preparation can also be performed in constant depth with a single
step of feed-forward from classical computation. Our construction thus exhibits
a robust superpolynomial quantum advantage for a sampling problem implemented
on a constant depth circuit with a single round of measurement and
feed-forward.</p>
</section>
<section id="unifying-quantum-verification-and-error-detection-theory-and-tools-for-optimisations">
<h3>Unifying Quantum Verification and Error-Detection: Theory and Tools for Optimisations<a class="headerlink" href="#unifying-quantum-verification-and-error-detection-theory-and-tools-for-optimisations" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://arxiv.org/abs/2206.00631">ArXiv</a></p>
<p><strong>Date de publication :</strong> 01/06/2022</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Theodoros Kapourniotis</p></li>
<li><p>Elham Kashefi</p></li>
<li><p>Dominik Leichtle</p></li>
<li><p>Luka Music</p></li>
<li><p>Harold Ollivier</p></li>
</ul>
<p><strong>Résumé :</strong>
With the advent of cloud-based quantum computing, it has become vital to provide strong guarantees that computations delegated by clients to quantum service providers have been executed faithfully. Secure - blind and verifiable - Delegated Quantum Computing (SDQC) has emerged as one of the key approaches to address this challenge, yet current protocols lack at least one of the following three ingredients: composability, noise-robustness and modularity.
To tackle this question, our paper lays out the fundamental structure of SDQC protocols, namely mixing two components: the computation which the client would like the server to perform and tests that are designed to detect a server’s malicious behaviour. Using this abstraction, our main technical result is a set of sufficient conditions on these components which imply the security and noise-robustness of generic SDQC protocols in the composable Abstract Cryptography framework. This is done by establishing a correspondence between these security properties and the error-detection capabilities of the test computations. Changing the types of tests and how they are mixed with the client’s computation automatically yields new SDQC protocols with different security and noise-robustness capabilities.
This approach thereby provides the desired modularity as our sufficient conditions on test computations simplify the steps required to prove the security of the protocols and allows to focus on the design and optimisation of test rounds to specific situations. We showcase this by systematising the search for improved SDQC protocols for Bounded-error Quantum Polynomial-time computations. The resulting protocols do not require more hardware on the server’s side than what is necessary to blindly delegate the computation without verification, and they outperform all previously known results.</p>
</section>
<section id="an-automated-deductive-verification-framework-for-circuit-building-quantum-programs">
<h3>An Automated Deductive Verification Framework for Circuit-building Quantum Programs<a class="headerlink" href="#an-automated-deductive-verification-framework-for-circuit-building-quantum-programs" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://arxiv.org/abs/2003.05841">ArXiv</a></p>
<p><strong>Date de publication :</strong> 12/03/2020</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Christophe Chareton</p></li>
<li><p>Sébastien Bardin</p></li>
<li><p>François Bobot</p></li>
<li><p>Valentin Perrelle</p></li>
<li><p>Benoit Valiron</p></li>
</ul>
<p><strong>Résumé :</strong><br />
While recent progress in quantum hardware open the door for significant speedup in certain key areas, quantum algorithms are still hard to implement right, and the validation of such quantum programs is a challenge. Early attempts either suffer from the lack of automation or parametrized reasoning, or target high-level abstract algorithm description languages far from the current de facto consensus of circuit-building quantum programming languages. As a consequence, no significant quantum algorithm implementation has been currently verified in a scale-invariant manner. We propose Qbricks, the first formal verification environment for circuit-building quantum programs, featuring clear separation between code and proof, parametric specifications and proofs, high degree of proof automation and allowing to encode quantum programs in a natural way, i.e. close to textbook style. Qbricks builds on best practice of formal verification for the classical case and tailor them to the quantum case: we bring a new domain-specific circuit-building language for quantum programs, namely Qbricks-DSL, together with a new logical specification language Qbricks-Spec and a dedicated Hoare-style deductive verification rule named Hybrid Quantum Hoare Logic. Especially, we introduce and intensively build upon HOPS, a higher-order extension of the recent path-sum symbolic representation, used for both specification and automation. To illustrate the opportunity of Qbricks, we implement the first verified parametric implementations of several famous and non-trivial quantum algorithms, including the quantum part of Shor integer factoring (Order Finding - Shor-OF), quantum phase estimation (QPE) - a basic building block of many quantum algorithms, and Grover search. These breakthroughs were amply facilitated by the specification and automated deduction principles introduced within Qbricks.</p>
</section>
<section id="fasquic-flexible-architecture-for-scalable-spin-qubit-control">
<h3>FASQuiC: Flexible architecture for scalable spin qubit control<a class="headerlink" href="#fasquic-flexible-architecture-for-scalable-spin-qubit-control" title="Lien vers cette rubrique">#</a></h3>
<p><strong>Lien de l’article :</strong> <a class="reference external" href="https://cea.hal.science/cea-04612422">HAL</a></p>
<p><strong>Date de publication :</strong> 14/06/2024</p>
<p><strong>Auteur(s) :</strong></p>
<ul class="simple">
<li><p>Mathieu Toubeix</p></li>
<li><p>Eric Guthmuller</p></li>
<li><p>Adrian Evans</p></li>
<li><p>Antoine Faurie</p></li>
<li><p>Tristan Meunier</p></li>
</ul>
<p><strong>Résumé :</strong><br />
As scaling becomes a key issue for Large Scale Quantum (LSQ) computing, hardware
control systems will become increasingly costly in resources. This paper presents a compact Direct Digital
Synthesis (DDS) architecture for signal generation adapted for spin qubits, which is scalable in terms of
waveform accuracy and the number of synchronized channels. The architecture can produce programmable
combinations of ramps, frequency combs and Arbitrary Waveform Generation (AWG) at 5 GS/s, with
a worst-case digital feedback latency of 76.8 ns. The FPGA-based system is highly configurable and
takes advantage of bitstream switching to achieve the high flexibility required for scalable calibration.
The architecture also provides GHz rate multiplexed I/Q single-side band (SSB) modulation for scalable
reflectometry. This architecture has been validated in hardware on a Xilinx ZCU111 FPGA demonstrating
the mixing of complex signals and the quality of the frequency comb generation for multiplexed control
and measurement. The key benefits of this design are the increase of controllability of ramps at the Digital
to Analog Converter (DAC) frequency and the reduction in memory requirements by several orders of
magnitude compared to existing AWG-based architectures. The hardware for a single channel is very
compact, 2% of ZCU111 logic resources for one DAC lane in the default configuration, leaving significant
circuit resources for integrated feedback, calibration and Quantum Error Correction (QEC).</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="qimaera.html"
       title="page précédente">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">précédent</p>
        <p class="prev-next-title">Qimaera</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contenu
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#calcul-hybride-classique-quantique">Calcul hybride classique/quantique</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithme-circuit">Algorithme/circuit</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#formal-methods-for-quantum-programs-a-survey">Formal Methods for Quantum Programs: A Survey</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#optimal-hadamard-gate-count-for-clifford-t-synthesis-of-pauli-rotations-sequences">Optimal Hadamard gate count for Clifford<span class="math notranslate nohighlight">\(+T\)</span> synthesis of Pauli rotations sequences</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#on-the-hardness-of-analyzing-quantum-programs-quantitatively">On the Hardness of Analyzing Quantum Programs Quantitatively</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#completeness-of-sum-over-paths-for-toffoli-hadamard-and-the-dyadic-fragments-of-quantum-computation">Completeness of Sum-Over-Paths for Toffoli-Hadamard and the Dyadic Fragments of Quantum Computation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rewriting-and-completeness-of-sum-over-paths-in-dyadic-fragments-of-quantum-computing">Rewriting and Completeness of Sum-Over-Paths in Dyadic Fragments of Quantum Computing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-complete-equational-theory-for-quantum-circuits">A Complete Equational Theory for Quantum Circuits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-circuit-completeness-extensions-and-simplifications">Quantum Circuit Completeness: Extensions and Simplifications</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-curry-howard-correspondence-for-linear-reversible-computation">A Curry-Howard Correspondence for Linear, Reversible Computation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proceedings-of-the-twentieth-international-conference-on-quantum-physics-and-logic">Proceedings of the Twentieth International Conference on Quantum Physics and Logic</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimal-equational-theories-for-quantum-circuits">Minimal Equational Theories for Quantum Circuits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-pragma-based-c-framework-for-hybrid-quantum-classical-computation">A Pragma-Based C Framework for Hybrid Quantum Classical Computation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-tree-approach-pauli-decomposition-algorithm-with-application-to-quantum-computing">A tree-approach Pauli decomposition algorithm with application to quantum computing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#experimenting-with-hybrid-quantum-optimization-in-hpc-software-stack-for-cpu-register-allocation">Experimenting with hybrid quantum optimization in HPC software stack for CPU register allocation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-computing-with-and-for-many-body-physics">Quantum computing with and for many-body physics</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#langage-de-programmation">Langage de programmation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-programming-language-characterizing-quantum-polynomial-time">A programming language characterizing quantum polynomial time</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-expectation-transformers-for-cost-analysis">Quantum Expectation Transformers for Cost Analysis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#qimaera-type-safe-variational-quantum-programming-in-idris">Qimaera: Type-safe (Variational) Quantum Programming in Idris</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#addition-and-differentiation-of-zx-diagrams">Addition and Differentiation of ZX-diagrams</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lov-calculus-a-graphical-language-for-linear-optical-quantum-circuits">LOv-Calculus: A Graphical Language for Linear Optical Quantum Circuits</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#perceval-a-software-platform-for-discrete-variable-photonic-quantum-computing">Perceval: A Software Platform for Discrete Variable Photonic Quantum Computing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#physique">Physique</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#efficient-and-robust-estimation-of-many-qubit-hamiltonians">Efficient and robust estimation of many-qubit Hamiltonians</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#efficient-learning-of-ground-thermal-states-within-phases-of-matter">Efficient learning of ground &amp; thermal states within phases of matter</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#provably-efficient-learning-of-phases-of-matter-via-dissipative-evolutions">Provably Efficient Learning of Phases of Matter via Dissipative Evolutions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#many-body-entropies-and-entanglement-from-polynomially-many-local-measurements">Many-body entropies and entanglement from polynomially-many local measurements</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#chimie">Chimie</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#greedy-gradient-free-adaptive-variational-quantum-algorithms-on-a-noisy-intermediate-scale-quantum-computer">Greedy Gradient-free Adaptive Variational Quantum Algorithms on a Noisy Intermediate Scale Quantum Computer</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#overlap-adapt-vqe-practical-quantum-chemistry-on-quantum-computers-via-overlap-guided-compact-ansatze">Overlap-ADAPT-VQE: Practical Quantum Chemistry on Quantum Computers via Overlap-Guided Compact Ansätze</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sparse-quantum-state-preparation-for-strongly-correlated-systems">Sparse Quantum State Preparation for Strongly Correlated Systems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dilute-measurement-induced-cooling-into-many-body-ground-states">Dilute measurement-induced cooling into many-body ground states</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#machine-learning-optimisation">Machine learning/optimisation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#trainability-and-expressivity-of-hamming-weight-preserving-quantum-circuits-for-machine-learning">Trainability and Expressivity of Hamming-Weight Preserving Quantum Circuits for Machine Learning</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-higher-order-binary-optimization-problems-on-nisq-devices-experiments-and-limitations">Solving Higher Order Binary Optimization Problems on NISQ Devices: Experiments and Limitations</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cryptographie-cryptanalyse">Cryptographie/cryptanalyse</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#variational-loop-vertex-expansion">Variational Loop Vertex Expansion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#even-cycle-detection-in-the-randomized-and-quantum-congest-model">Even-Cycle Detection in the Randomized and Quantum CONGEST Model</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#a-functional-analysis-approach-to-symbolic-regression">A Functional Analysis Approach to Symbolic Regression</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-complexity-of-testing-signed-graph-clusterability">(Quantum) complexity of testing signed graph clusterability</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-speedups-for-linear-programming-via-interior-point-methods">Quantum speedups for linear programming via interior point methods</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-walks-the-discrete-wave-equation-and-chebyshev-polynomials">Quantum walks, the discrete wave equation and Chebyshev polynomials</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantum-security-of-subset-cover-problems">Quantum security of subset cover problems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-special-case-of-cyclotomic-fields-in-quantum-algorithms-for-unit-groups">The special case of cyclotomic fields in quantum algorithms for unit groups</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#caracterisation-correction-d-erreur">Caractérisation/correction d’erreur</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#efficient-learning-of-the-structure-and-parameters-of-local-pauli-noise-channels">Efficient learning of the structure and parameters of local Pauli noise channels</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#information-theoretic-generalization-bounds-for-learning-from-quantum-data">Information-theoretic generalization bounds for learning from quantum data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lower-bounds-on-learning-pauli-channels">Lower Bounds on Learning Pauli Channels</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#robust-sparse-iqp-sampling-in-constant-depth">Robust sparse IQP sampling in constant depth</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#unifying-quantum-verification-and-error-detection-theory-and-tools-for-optimisations">Unifying Quantum Verification and Error-Detection: Theory and Tools for Optimisations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#an-automated-deductive-verification-framework-for-circuit-building-quantum-programs">An Automated Deductive Verification Framework for Circuit-building Quantum Programs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fasquic-flexible-architecture-for-scalable-spin-qubit-control">FASQuiC: Flexible architecture for scalable spin qubit control</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
Par GENCI
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024 GENCI - All rights reserved.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>